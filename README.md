PKI предоставляет api для регистрации, проверки, перевыпуска X.509 сертификатов. 
Состав сертификата в соответствии со стандартом RFC 5280
 Certificate  ::=  SEQUENCE  {
        tbsCertificate       TBSCertificate,
        signatureAlgorithm   AlgorithmIdentifier,
        signatureValue       BIT STRING  
}
Поля сертификата:
Version  ::=  V3
CertificateSerialNumber  ::=  INTEGER (генерируется 160 бит)
   Validity ::= SEQUENCE {
        notBefore      Time,
        notAfter       Time 
}  (время валидации сертификата устанавливается в конфигурации)
SubjectPublicKeyInfo  ::=  SEQUENCE  {
        algorithm            AlgorithmIdentifier,
        subjectPublicKey     BIT STRING  
} Алгоритм (обычно RSA) + открытый ключ из CSR

issuer               Name (устанавливает имя УЦ, который подписал)
subject              Name Данные пользователя из CSR (CommonName, Email, Country и т.д.)

Extensions	
- keyUsage	digitalSignature, keyEncipherment
- basicConstraints	CA:FALSE
- subjectKeyIdentifier	Хэш открытого ключа субъекта (SHA-256)
- authorityKeyIdentifier	keyid УЦ
- subjectAltName	IP и DNS из CSR

Центры сертификации (X.509)
Version	v3
Serial Number	160-битное случайное число
Signature Algorithm	sha256WithRSAEncryption
Issuer	Для Intermediate CA — root CA
Для root CA — self-signed
Validity	Зависит от настроек, например, 10 лет
Subject	Данные центра сертификации (например, OU=IntermediateCA, CN=CA)
SubjectPublicKeyInfo	Алгоритм + открытый ключ
Extensions	
- basicConstraints	critical, CA:TRUE[, pathlen:0]
- keyUsage	critical, keyCertSign, cRLSign, digitalSignature
- subjectKeyIdentifier	Хэш открытого ключа
- authorityKeyIdentifier	keyid:always,issuer


Endpoit:

Post: "/api/cert/sign"
Описание: Подписывает переданный CSR и выдает X.509 сертификат.
Запрос:
{
  "csr": "-----BEGIN CERTIFICATE REQUEST-----\nMIIB...==\n-----END CERTIFICATE REQUEST-----",
}
Ответ:
{
  "certificate": "-----BEGIN CERTIFICATE-----\nMIIC...==\n-----END CERTIFICATE-----",
}

(Для OCSP стандарт RFC-6960)
Post: "/application/ocsp-request"
Запрос:
{
  "certificate": "-----BEGIN CERTIFICATE-----\nMIIC...==\n-----END CERTIFICATE-----",
    "isUser": "-----BEGIN CERTIFICATE-----\nMIIC...==\n-----END CERTIFICATE-----",
    "Hash": "crypto.SHA256",
}
Ответ:
{
    Serial    string `json:"serial"`
		OCSP      string `json:"OCSP"`
		Status    string `json:"status"`
		Timestamp string `json:"timestamp"`
}
Post: "/api/ocsp-request/serial"
Запрос:
{
  "serial": "",
}
Ответ:
{
    Serial    string `json:"serial"`
		OCSP      string `json:"OCSP"`
		Status    string `json:"status"`
		Timestamp string `json:"timestamp"`
}

Post, "/api/findUserInfo"
Запрос
{
	Username string `json:"name"`
}
Ответ:
{
		Serial      string `json:"serial"`
		Email       string `json:"email"`
		Status      string `json:"status"`
		PublicKey   string `json:"publicKey"`
		Certificate string `json:"certificate"`
	}

Post, "/api/createNewCert"
Запрос:
{
	Name      string `json:"username"`
	SignedCSR string `json:"csr"`
	Signature string `json:"signature"`
}
Ответ:
{
			Certificate string `json:"certificate"`
}

Policy (RFC 3647):
Политика Сертификации (Certificate Policy)
Документ CP-001
Идентификатор политики (OID): 1.2.643.100.111.1.1
Введение
  Обзор
Настоящая Политика Сертификации (CP) определяет правила и процедуры, которым должны следовать все участники инфраструктуры открытых ключей (PKI), включая Центры сертификации (CA), Регистрационные центры (RA), Владельцев сертификатов и Надёжных сторон. Этот документ соответствует структуре, определённой в RFC 3647.
  Название и идентификатор документа
Название: Политика Сертификации организации ООО «Подушко»
OID: 1.2.643.100.111.1.1
  Участники PKI
Центр Сертификации (CA): Выпускает, аннулирует и управляет сертификатами.
Владельцы сертификатов: Пользователи, у которых есть личные ключи и сертификаты.
  Сертификаты могут использоваться для:
Аутентификации
Шифрования
Цифровой подписи
  Администрирование политики
Политика разрабатывается и обновляется Администратором PKI. Утверждение новых редакций производится Доверенным органом организации.

  Определения и аббревиатуры
CP: Certificate Policy
CPS: Certification Practice Statement
PKI: Public Key Infrastructure

  Публикация и репозитории
CA публикует:
Сертификаты CA
Актуальную версию CP и CPS
Доступ осуществляется через HTTPS.

Идентификация и аутентификация
  Именование
Используются X.500-имена с уникальными Distinguished Names (DN).

  Первичная проверка личности
Отсутствует.
  Проверка личности при повторной выдаче
Проверка осуществляется с использованием действующего сертификата.
  Проверка личности при отзыве
Запросы на отзыв должны быть подписаны действующим ключом.

  Требования к жизненному циклу сертификатов
  Заявка на сертификат
Заявка подаётся через веб-интерфейс.

  Обработка заявки
RA проверяет данные и передаёт CA для выпуска сертификата.

  Выпуск сертификата
Сертификат подписывается закрытым ключом CA.

  Принятие сертификата
Сертификат считается принятым после его получения.

  Использование ключей и сертификатов
Владельцы обязаны:
Обеспечивать конфиденциальность закрытого ключа.
Использовать сертификат только в разрешённых целях.

  Продление сертификата
С помощью закрытого ключа пользователя.

  Перевыпуск сертификата
Требуется новый CSR и повторная проверка личности (подтверждение владения приватным ключом).

  Модификация сертификата
Разрешена модификация почты, путем перевыпуска сертификата. Остальные поля не подлежат модификации.

  Отзыв и приостановка
Выполняется по запросу владельца, RA или CA.

  Сервисы проверки статуса сертификата
OCSP-доступ предоставляется через URL указанный в CSP.

  Окончание действия сертификата
По истечении срока действия или отзыву.

  Резервное копирование и восстановление ключей
Поддерживается только для ключей шифрования. Применяются механизмы escrow и восстановления.

  Контроль за объектами, управлением и эксплуатацией
    Физическая безопасность
Серверы CA размещены в охраняемых помещениях с ограниченным доступом. RootCA хранится на локальной машине.

  Процедурный контроль
Функции RA и CA разделены. Все действия фиксируются.

  Ведение журналов
Журналируются все операции, связанные с сертификатами.

  Архивация записей
Хранятся не менее 7 лет. Архив защищён от несанкционированного доступа.

 Замена ключей
Периодическая ротация ключей CA. Новый сертификат публикуется заблаговременно.

  Аварийное восстановление
План восстановления при компрометации включает уведомление пользователей, генерацию новых ключей и повторный выпуск сертификатов.

  Прекращение работы CA или RA
Пользователи уведомляются заранее. Все сертификаты отзываются, данные архивируются.

  Технические меры безопасности
  Генерация и установка ключевых пар
Ключи генерируются в HSM. Хранение закрытых ключей — в зашифрованном виде.

  Защита закрытого ключа
Доступ только авторизованным пользователям. Используются пароли (для пользовательского сертификата - пароль устанавливает пользователь).

  Данные активации
PIN-коды и пароли должны быть сложными и меняться не реже чем раз в 180 дней.

 Профили сертификатов, CRL и OCSP
 CRL хранится на сервере в базе данных. Данные CRL не публикуются. Всю информацию можно получить с помощью OCPS.
   Профиль сертификатов
Соответствуют X.509 v3. Указываются расширения: keyUsage, extendedKeyUsage, subjectAltName.

  Профиль OCSP
Поддерживается стандарт RFC 6960. Ответы подписаны OCSP-сервером.

  Представления и гарантии
CA гарантирует, что сертификаты выдаются после достаточной проверки.

  Отказ от гарантий
CA не гарантирует отсутствие уязвимостей в криптографических алгоритмах.

  Срок действия и прекращение
Политика действует до её официальной замены или отмены.

 Уведомления
Осуществляются через официальный сайт CA и электронную почту.

 Прочие положения
Дополнительные условия могут быть изложены в CPS.



Описание логики работы CA (CSP):
Сертификатный центр (CA) выполняет следующие функции:
Метод: createCertificate(csr *x509.CertificateRequest)
Генерируется уникальный серийный номер с помощью криптостойкой случайной функции.
Создается шаблон сертификата на основе данных из CSR:
Subject, DNSNames, IPAddresses, EmailAddresses.
Устанавливаются ключевые флаги (KeyUsage, ExtKeyUsage).
Устанавливается срок действия (NotBefore, NotAfter).
Указывается идентификатор подписавшего (AuthorityKeyId), вычисленный по публичному ключу CA.
Подписывается этот сертификат с использованием приватного ключа CA и сохраняется в DER-формате.
Возвращаются как *x509.Certificate (шаблон), так и []byte — сериализованный сертификат.

Метод: canUse()
Проверяет, был ли промежуточный сертификат CA подписан корневым CA (CheckSignatureFrom).
Удостоверяется, что срок действия промежуточного сертификата достаточен для выдачи новых сертификатов (например, если срок действия меньше, чем требуется клиенту — отказ).

Функция: SaveCertAsPEM(certDER []byte, filename string)
Конвертирует DER-сертификат в PEM-формат.
Сохраняет его в файл filename.

Функция: generateSerialNumber()
Генерирует случайное big.Int до 160 бит для использования как серийный номер сертификата.

Метод: findIsUser(user *x509.Certificate)
Проверяет, был ли сертификат user подписан одним из доверенных (trusted) CA.
Проверяет, что:
Issuer есть в списке ca.trust.
У CA есть право подписания сертификатов (KeyUsageCertSign).
Подпись пользователя действительно проверяется на этом CA.

OCSP:
OCSP-проверка — общий цикл
  1. Клиент создаёт OCSP-запрос
сертификат клиента (clientCert)
сертификат издателя (isUser, т.е. CA)
алгоритм хэширования (SHA-256)

Создаётся структура ocsp.Request, сериализованная в DER ([]byte), которая содержит:
SerialNumber запрашиваемого сертификата
IssuerNameHash, IssuerKeyHash — хэши информации об издателе (CA)

2. Клиент отправляет HTTP-запрос на OCSP-эндпоинт
3. OCSP-сервер принимает запрос и парсит его
Проверяется:
что запрос корректный
SerialNumber запрашиваемого сертификата

4. Проверка отзыва (revocation) сертификата
Проверка в БД списка отозванных сертификатов
Если сертификат отозван:
Получается причина и дата отзыва
Генерируется ответ с Status = ocsp.Revoked

resp := ocsp.Response{
	Status:           ocsp.Revoked,
	SerialNumber:     ocspReq.SerialNumber,
	ThisUpdate:       time.Now(),
	NextUpdate:       time.Now().Add(24 * time.Hour),
	RevokedAt:        time_revoke,
	RevocationReason: reason,
}
5. Если не отозван, то ищется в БД выданных сертификатов
Возвращает ocsp.Good, Revoked, Unknown

6. Поиск подходящего CA для подписи OCSP-ответа
OCSP ответ подписывается с помощью CA, который выдал сертификат пользователю.
Сравниваются хэши Subject и PublicKeyInfo для поиска подходящего CA

7. Генерация и подпись OCSP-ответа
respByte, err := ocsp.CreateResponse(isUserCA.cert, isUserCA.cert, resp, isUserCA.privateKey)
Ответ подписывается закрытым ключом CA
Содержит:
Status
SerialNumber
ThisUpdate / NextUpdate

8. Сервер возвращает application/ocsp-response
w.Header().Set("Content-Type", "application/ocsp-response")
_, _ = w.Write(respBytes)

Конфигурация в формате JSON:
  "trustPath": "cmd/web/trustCertificate",   #Путь к папке, содержащей все доверенные сертификаты
  "keyPath": "cmd/web/root/ca/intermediate/private", #Путь к папке с приватными ключами
  "rootCACertificatePath": "cmd/web/trustCertificate/ca.cert.pem", #Путь к файлу корневого сертификата PKI
  "tlsServerCert": "cmd/web/tls/serverTLS.crt", #Путь к сертификату сервера
  "tlsServerKey": "cmd/web/tls/keyTLS.pem",     #Путь к приватному ключу сервера
  "validationDays": 180,                        #Количество дней на которое пользователям выдают ключи
   "database": {                                #Конфигурация подключения к базе данных
    "user": "root",                              #Имя пользователя БД
    "password": "",                              #Пароль пользователя
    "host": "localhost",                         #Хост
    "port": 3306,                                #Порт
    "name": "pki"                                #Название базы данных
  },
  "caKeys":                                     #Информация о промежуточных ЦС
    {
      "certFile": "intermediate.cert.pem",      #Файл ЦС 
      "keyFile": "intermediate.key.pem",        #Файл приватного ключа ЦС
      "password": ""                             #Пароль от приватного ключа
    }
}
Для добавления новых ЦС необходимо подписать с помощью корневого сертификата, а также добавить сертификат по пути: $trustPath Приватный ключ добавить по пути $keyPath
Для запуска проекта перейти в корневую директорию и ввести команду: go run ./cmd/web
